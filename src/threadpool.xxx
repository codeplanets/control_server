#include "threadpool.h"
#include "errorcode.h"
#include "log.h"
#include "exception.h"

namespace core {
    using namespace internal;

    ThreadPool::ThreadPool()
    : m_vecInstance()
    , m_qReady()
    , m_bEscapeFlag(false) {

    }

    ThreadPool::~ThreadPool() {

    }

    int ThreadPoolWorker(void* pContext);
    ECODE ThreadPool::init(size_t poolCount, E_THREAD_PRIORITY nPriority) {
        try {
            m_bEscapeFlag = false;
            m_vecInstance.resize(poolCount);

            size_t i;
            for (i = 0; i < m_vecInstance.size(); i++) {
                m_vecInstance[i].strName = i;
                m_vecInstance[i].pOwner = this;
                m_vecInstance[i].event = CreateEvent(false, false);
                m_vecInstance[i].pbEscapeFlag = &m_bEscapeFlag;

                m_vecInstance[i].thread = core::CreateThread(ThreadPoolWorker, &m_vecInstance[i]);
                if (NULL == m_vecInstance[i].hThread)
                    throw exception_format(TEXT("%s creating failed"), m_vecInstance[i].strName.c_str());

                m_qReady.Push(&m_vecInstance[i]);
            }
            logInfo(TEXT("Thread pool count:%u created."), poolCount);
        } catch (std:execption& e) {
            logError("%s", e.what());
            destroy();
            return EC_INTERNAL_ERROR;
        }

        return EC_SUCCESS;
    }

    void ThreadPool::destroy(void) {
        m_bEscapeFlg = true;

        size_t i;
        for (i = 0; i < m_vecInstance.size(); i++) {
            ST_THREADPOOL_DATA& refInstance = m_vecInstance[i];
            if (refInstance.thread) {
                SetEvent(refInstance.event);
            
                int nErrCode = 0;
                core::JoinThread(refInstance.thread, &nErrCode);
                refInstance.thread = NULL;
            }

            if (refInstance.event) {
                CloseEvent(refInstance.event);
                refInstance.event = NULL;
            }
        }
        m_vecInstance.clear();
    }

    ECODE ThreadPool::createThread(int(*pfEntry)(void* pContext), void* pContext) {
        ST_THREADPOOL_DATA* pThreadData = NULL;
        ECODE nRet = m_qReady.Pop(pThreadData);
        if (EC_SUCCESS != nRet) {
            static int nRejectCount = 0;
            logError("No more thread... try count:%d", InterlockedIncrement_(&nRejectCount));
            return nRet;
        }

        pThreadData->pfThreadFunc = pfEntry;
        pThreadData->pContext = pContext;
        SetEvent(pThreadData->event);
        return EC_SUCCESS;
    }

    void ThreadPool::returnThread(THREADPOOL thread) {
        m_qReady.Push(thread);
    }

    int ThreadPoolWorker(void* pContext)
    {
        ST_THREADPOOL_DATA* pThreadData = (ST_THREADPOOL_DATA*)pContext;
        logInfo(TEXT("%s started."), pThreadData->strName.c_str());

        while (!*pThreadData->pbEscapeFlag)
        {
            EWAIT nRet = WaitForEvent(pThreadData->event, INFINITE);
            if (nRet != 0)
                break;

            if (NULL == pThreadData->pfThreadFunc)
                break;

            int nExitCode = pThreadData->pfThreadFunc(pThreadData->pContext);
            logInfo(TEXT("%s finished with exit-code:%d"), pThreadData->strName.c_str(), nExitCode);

            pThreadData->pfThreadFunc = NULL;
            pThreadData->pContext = NULL;
            pThreadData->pOwner->returnThread(pThreadData);
        }

        logInfo(TEXT("%s escaped."), pThreadData->strName.c_str());
        return 0;
    }
}